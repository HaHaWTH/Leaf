From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <fsjk947@gmail.com>
Date: Tue, 21 May 2024 21:29:37 +0800
Subject: [PATCH] Multi-thread-world-ticking


diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index dadc5ee6a79a47cbebcc8e8c943c2147cc16d732..8e765794958b51b73f567997b5b73e8ff4db122f 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -45,7 +45,7 @@ class PaperEventManager {
         final boolean isAsync = event.isAsynchronous();
         if (isAsync && onPrimaryThread) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!isAsync && !onPrimaryThread && !this.server.isStopping()) {
+        } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping() && !Thread.currentThread().getName().startsWith("WorldTicker")) {
             // Leaf start - petal
             if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
                 net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(event::callEvent);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c7f44250b1801c581420f93d357d64f615949691..62322f7ac930142f909271b254f2ceb7b3489576 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -10,6 +10,7 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
@@ -27,15 +28,9 @@ import java.nio.file.Files;
 import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.security.KeyPair;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Optional;
@@ -134,13 +129,13 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 import net.minecraft.world.level.storage.WorldData;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+import org.dreeam.leaf.async.ticking.NamedTickThreadFactory;
 import org.galemc.gale.configuration.GaleConfigurations;
 import org.slf4j.Logger;
 
 // CraftBukkit start
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
-import java.util.Random;
 // import jline.console.ConsoleReader; // Paper
 import joptsimple.OptionSet;
 import net.minecraft.nbt.NbtException;
@@ -235,6 +230,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private int playerIdleTimeout;
     private final long[] tickTimesNanos;
     private long aggregatedTickTimesNanos;
+    // Leaf start - Multithreaded WorldTicking
+    public static java.util.concurrent.ExecutorService worldTickerPool;
+    public int tickerThreadMax = setupThreadCount();
+    private ThreadGroup worldThreadGroup = null;
+    // Leaf end
     // Paper start - Add tick times API and /mspt command
     public final TickTimes tickTimes5s = new TickTimes(100);
     public final TickTimes tickTimes10s = new TickTimes(200);
@@ -332,12 +332,20 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return s0;
     }
 
+    // Leaf start - Multithreaded WorldTicking
+
+    public int setupThreadCount() {
+        int avalibleJVMThreads = Runtime.getRuntime().availableProcessors() * 2;
+        return avalibleJVMThreads < 3 ? avalibleJVMThreads : avalibleJVMThreads >= org.dreeam.leaf.config.modules.async.MultiThreadedWorldTicking.multiThreadWorldTickingThreads ? org.dreeam.leaf.config.modules.async.MultiThreadedWorldTicking.multiThreadWorldTickingThreads : avalibleJVMThreads;
+    }
+    // LeF end
     public MinecraftServer(OptionSet options, WorldLoader.DataLoadContext worldLoader, Thread thread, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PackRepository resourcepackrepository, WorldStem worldstem, Proxy proxy, DataFixer datafixer, Services services, ChunkProgressListenerFactory worldloadlistenerfactory) {
         super("Server");
         SERVER = this; // Paper - better singleton
         this.random = RandomSource.create();
         this.port = -1;
         this.levels = Maps.newLinkedHashMap();
+        worldTickerPool = Executors.newFixedThreadPool(this.tickerThreadMax, new NamedTickThreadFactory("WorldTicker")); // Leaf - Multithreaded WorldTicking
         this.running = true;
         this.ticksUntilAutosave = 6000;
         this.tickTimesNanos = new long[100];
@@ -1030,6 +1038,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - move final shutdown items here
         LOGGER.info("Closing Thread Pool");
         Util.shutdownExecutors(); // Paper
+        MinecraftServer.worldTickerPool.shutdown(); // Leaf - Multithreaded WorldTicking
         LOGGER.info("Closing Server");
         try {
             net.minecrell.terminalconsole.TerminalConsoleAppender.close(); // Paper - Use TerminalConsoleAppender
@@ -1468,6 +1477,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public final void executeMidTickTasks() {
+        if (true) return; // Leaf - disable mid-tick tasks
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
@@ -1730,7 +1740,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
-        for (final ServerLevel level : this.getAllLevels()) {
+        /*for (final ServerLevel level : this.getAllLevels()) {
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1745,18 +1755,20 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
                 entityplayer.connection.send(packet); // Add support for per player time
             }
-        }
+        } */
         // Paper end - Perf: Optimize time updates
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
         Iterator iterator = this.getAllLevels().iterator(); // Paper - Throw exception on world create while being ticked; move down
-        while (iterator.hasNext()) {
+        final AtomicBoolean finishedTicking = new AtomicBoolean(false);
+        List<com.mojang.datafixers.util.Pair<Runnable, ServerLevel>> worldTicks = new ArrayList();
+        while (iterator.hasNext() && !finishedTicking.get()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
-            worldserver.updateLagCompensationTick(); // Paper - lag compensation
-            worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
+            //worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
+            //worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
+            //net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+            //worldserver.updateLagCompensationTick(); // Paper - lag compensation
+            //worldserver.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur
 
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
@@ -1765,22 +1777,48 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // CraftBukkit end */
 
             try {
-                worldserver.tick(shouldKeepTicking);
+                if (worldserver == null) {
+                    finishedTicking.set(true);
+                    break;
+                }
+                //worldserver.tick(shouldKeepTicking);
+                Pair<Runnable, ServerLevel> tick = worldserver.tick(shouldKeepTicking, tickCount);
                 // Paper start
-                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                /*for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
                     regionManager.recalculateRegions();
-                }
+                }*/
                 // Paper end
+                if (tick != null) worldTicks.add(tick); // Leaf
             } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-
+                if (throwable instanceof NoSuchElementException) return; // Leaf
+                CrashReport crashreport = CrashReport.forThrowable(throwable, "Exception preparing WorldTick!"); // Leaf
                 worldserver.fillReportDetails(crashreport);
                 throw new ReportedException(crashreport);
             }
 
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            //worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
+        // Leaf start - Multithreaded WorldTicking
+        List<CompletableFuture<Void>> futureTicks = new ArrayList();
+        for(com.mojang.datafixers.util.Pair<Runnable, ServerLevel> tick : worldTicks){
+            futureTicks.add(CompletableFuture.runAsync(() -> {
+                try {
+                    tick.getFirst().run();
+                } catch (Exception throwable) {
+                    CrashReport report = CrashReport.forThrowable(throwable, "Exception ticking world!");
+                    tick.getSecond().fillReportDetails(report);
+                    throw new ReportedException(report);
+                }
+                }, this.worldTickerPool));
+        }
+        CompletableFuture<Void> allTicks = CompletableFuture.allOf(futureTicks.toArray(new CompletableFuture[0]));
+        try {
+            allTicks.get();
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+        // Leaf end
 
         this.getConnection().tick();
         this.playerList.tick();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 2109fedc6d09fb783e0042289a9c5d372933f4ff..4a044d11c231689e94f9499f73dd31e50261e7d9 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1158,7 +1158,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
 
     // Paper start - optimised tracker
-    private final void processTrackQueue() {
+    private synchronized final void processTrackQueue() {
             if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
                 if (this.multithreadedTracker == null) {
                     this.multithreadedTracker = new org.dreeam.leaf.async.tracker.MultithreadedTracker(this.level.chunkSource.entityTickingChunks, this.trackerMainThreadTasks);
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index dced0a22e924838b13edd0c24a7d3fb3de9242d6..2b87605efb40afec5f8e2f441714e4a01b871459 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -53,17 +53,7 @@ import net.minecraft.core.registries.Registries;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
-import net.minecraft.network.protocol.game.ClientboundBlockDestructionPacket;
-import net.minecraft.network.protocol.game.ClientboundBlockEventPacket;
-import net.minecraft.network.protocol.game.ClientboundDamageEventPacket;
-import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
-import net.minecraft.network.protocol.game.ClientboundExplodePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
-import net.minecraft.network.protocol.game.ClientboundLevelParticlesPacket;
-import net.minecraft.network.protocol.game.ClientboundSetDefaultSpawnPositionPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundEntityPacket;
-import net.minecraft.network.protocol.game.ClientboundSoundPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
+import net.minecraft.network.protocol.game.*;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
@@ -234,6 +224,13 @@ public class ServerLevel extends Level implements WorldGenLevel {
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur
+    public Thread currentTickingThread = null;
+
+    public static Throwable getAddToWorldStackTrace(Entity entity) {
+        final Throwable thr = new Throwable(entity + " Added to world at " + new java.util.Date());
+        io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateThrowable(thr);
+        return thr;
+    }
 
     public LevelChunk getChunkIfLoaded(int x, int z) {
         return this.chunkSource.getChunkAtIfLoadedImmediately(x, z); // Paper - Use getChunkIfLoadedImmediately
@@ -834,8 +831,33 @@ public class ServerLevel extends Level implements WorldGenLevel {
         return this.structureManager;
     }
 
-    public void tick(BooleanSupplier shouldKeepTicking) {
-        this.handlingTick = true;
+    public Pair<Runnable, ServerLevel> tick(BooleanSupplier shouldKeepTicking, int tickCount) {
+        return new Pair<Runnable, ServerLevel>(() -> {
+            this.handlingTick = true;
+            if (this.currentTickingThread != Thread.currentThread()) {this.currentTickingThread = Thread.currentThread();}
+            //ProfilerFiller gameprofilerfiller = this.getProfiler(); // Purpur
+            // Moved from MinecraftSever
+            final boolean doDaylight = this.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
+            final long dayTime = this.getDayTime();
+            long worldTime = this.getGameTime();
+            final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
+            for (Player entityhuman : this.players()) {
+                if (!(entityhuman instanceof ServerPlayer) || (!this.isForceTime() && (tickCount + entityhuman.getId()) % 20 != 0)) {
+                    continue;
+                }
+                ServerPlayer entityplayer = (ServerPlayer) entityhuman;
+                long playerTime = entityplayer.getPlayerTime();
+                ClientboundSetTimePacket packet = (playerTime == dayTime) ? worldPacket :
+                        new ClientboundSetTimePacket(worldTime, playerTime, doDaylight);
+                entityplayer.connection.send(packet);
+            }
+            this.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0;
+            this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = this.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0;
+            this.updateLagCompensationTick();
+            this.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0;
+            // Move end
+            // Leaf end
         TickRateManager tickratemanager = this.tickRateManager();
         boolean flag = tickratemanager.runsNormally();
 
@@ -882,7 +904,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             this.raids.tick();
         }
 
-        this.getChunkSource().tick(shouldKeepTicking, true);
+        // this.getChunkSource().tick(shouldKeepTicking, true);
         if (flag) {
             this.runBlockEvents();
         }
@@ -906,6 +928,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
                     } else if (!tickratemanager.isEntityFrozen(entity)) {
+                        if (entity.isRemoved()) return;
                         entity.checkDespawn();
                         if (true || this.chunkSource.chunkMap.getDistanceManager().inEntityTickingRange(entity.chunkPosition().toLong())) { // Paper - now always true if in the ticking list
                             Entity entity1 = entity.getVehicle();
@@ -940,6 +963,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
 
         //this.entityManager.tick(); // Paper - rewrite chunk system
+            // Leaf start - Multithreaded WorldTicking
+            for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : this.getChunkSource().chunkMap.regionManagers) {
+                regionManager.recalculateRegions();
+            }
+            this.getChunkSource().tick(shouldKeepTicking, true);
+            this.explosionDensityCache.clear();
+            // Leaf end
+        }, this);
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/util/ThreadingDetector.java b/src/main/java/net/minecraft/util/ThreadingDetector.java
index 84b3a37fe2a4597312c26abded08a45e7218cd17..914dd7808c6c87e867d540b64fb3fb9c762749a2 100644
--- a/src/main/java/net/minecraft/util/ThreadingDetector.java
+++ b/src/main/java/net/minecraft/util/ThreadingDetector.java
@@ -33,18 +33,20 @@ public class ThreadingDetector {
 
         try {
             this.stackTraceLock.lock();
-            if (!this.lock.tryAcquire()) {
-                this.threadThatFailedToAcquire = Thread.currentThread();
-                bl = true;
-                this.stackTraceLock.unlock();
+            if(!(Thread.currentThread() instanceof io.papermc.paper.util.TickThread)) {
+                if (!this.lock.tryAcquire()) {
+                    this.threadThatFailedToAcquire = Thread.currentThread();
+                    bl = true;
+                    this.stackTraceLock.unlock();
 
-                try {
-                    this.lock.acquire();
-                } catch (InterruptedException var6) {
-                    Thread.currentThread().interrupt();
-                }
+                    try {
+                        this.lock.acquire();
+                    } catch (InterruptedException var6) {
+                        Thread.currentThread().interrupt();
+                    }
 
-                throw this.fullException;
+                    throw this.fullException;
+                }
             }
         } finally {
             if (!bl) {
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 386fd36c56787966537df63337534c039e6858d0..f5ed6fd9412894498fc567cef3caba089592de28 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -3967,8 +3967,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 }).orElse(null); // CraftBukkit - decompile error
             }
         } else {
-            BlockPos blockposition1 = flag1 ? ServerLevel.END_SPAWN_POINT : destination.getSharedSpawnPos();
-
+            BlockPos blockposition1 = flag1 ? ServerLevel.END_SPAWN_POINT.offset(0, 1, 0) : destination.getSharedSpawnPos();
             destination.getChunkSource().addRegionTicket(TicketType.PORTAL, new ChunkPos(blockposition1), 3, blockposition1);
             int i;
 
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 749fa63c641c1cb54445c85721c795355ffae123..faf19a80f2019678a76184289fd9ef80cdbd33e7 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1353,9 +1353,9 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             } else if (flag && this.shouldTickBlocksAt(tickingblockentity.getPos())) {
                 tickingblockentity.tick();
                 // Paper start - execute chunk tasks during tick
-                if ((this.tileTickPosition & 7) == 0) {
-                    MinecraftServer.getServer().executeMidTickTasks();
-                }
+                //if ((this.tileTickPosition & 7) == 0) {
+                //    MinecraftServer.getServer().executeMidTickTasks();
+                //}
                 // Paper end - execute chunk tasks during tick
             }
         }
@@ -1368,7 +1368,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
             tickConsumer.accept(entity);
-            MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick
+            //MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick
         } catch (Throwable throwable) { // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
             if (throwable instanceof ThreadDeath) throw throwable; // Paper
             // Paper start - Prevent block entity and entity crashes
diff --git a/src/main/java/org/dreeam/leaf/async/ticking/NamedTickThreadFactory.java b/src/main/java/org/dreeam/leaf/async/ticking/NamedTickThreadFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..b627e13b94e326aad733afda38fb2a12eb130fcf
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/async/ticking/NamedTickThreadFactory.java
@@ -0,0 +1,64 @@
+package org.dreeam.leaf.async.ticking;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.TickThread;
+import org.slf4j.Logger;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class NamedTickThreadFactory implements ThreadFactory { // Extends the functionality of the NamedThreadFactory by vanilla
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private final ThreadGroup group;
+    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private final String namePrefix;
+    private int priority;
+    private boolean daemon;
+
+    public NamedTickThreadFactory(String name) {
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = 5;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = false;
+    }
+
+    public NamedTickThreadFactory(String name, int priority, String threadName, boolean daemon){
+        SecurityManager securityManager = System.getSecurityManager();
+        this.group = securityManager != null ? securityManager.getThreadGroup() : Thread.currentThread().getThreadGroup();
+        this.namePrefix = name + "-";
+        this.priority = priority;
+        this.daemon = daemon;
+    }
+
+    @Override
+    public Thread newThread(Runnable runnable) {
+        TickThread thread = new TickThread(runnable, namePrefix + this.threadNumber.getAndIncrement());
+        thread.setDaemon(daemon);
+        thread.setUncaughtExceptionHandler((threadx, throwable) -> {
+            LOGGER.error("Caught exception in thread {} from {}", threadx, runnable);
+            LOGGER.error("", throwable);
+        });
+        if (thread.getPriority() != priority) {
+            thread.setPriority(priority);
+        }
+
+        return thread;
+    }
+}
+
diff --git a/src/main/java/org/dreeam/leaf/config/modules/async/MultiThreadedWorldTicking.java b/src/main/java/org/dreeam/leaf/config/modules/async/MultiThreadedWorldTicking.java
new file mode 100644
index 0000000000000000000000000000000000000000..384859afea156a388a99b0b213caeb0604bb2149
--- /dev/null
+++ b/src/main/java/org/dreeam/leaf/config/modules/async/MultiThreadedWorldTicking.java
@@ -0,0 +1,36 @@
+package org.dreeam.leaf.config.modules.async;
+
+import com.electronwill.nightconfig.core.file.CommentedFileConfig;
+import net.minecraft.server.MinecraftServer;
+import org.dreeam.leaf.config.ConfigInfo;
+import org.dreeam.leaf.config.EnumConfigCategory;
+import org.dreeam.leaf.config.IConfigModule;
+
+public class MultiThreadedWorldTicking implements IConfigModule {
+
+    @Override
+    public EnumConfigCategory getCategory() {
+        return EnumConfigCategory.ASYNC;
+    }
+
+    @Override
+    public String getBaseName() {
+        return "multi_thread_world_ticking";
+    }
+
+    @ConfigInfo(baseName = "max-threads")
+    public static int multiThreadWorldTickingThreads = 3;
+    @Override
+    public void onLoaded(CommentedFileConfig config) {
+        config.setComment("async.multi_thread_world_ticking", """
+                WARNING! Multi-thread world ticking is not stable currently.
+                You may encounter a bunch of issues""");
+
+        if (multiThreadWorldTickingThreads < 0)
+            multiThreadWorldTickingThreads = Math.max(Runtime.getRuntime().availableProcessors() + multiThreadWorldTickingThreads, 1);
+        else if (multiThreadWorldTickingThreads == 0)
+            multiThreadWorldTickingThreads = Math.max(Runtime.getRuntime().availableProcessors() / 4, 1);
+        else
+            MinecraftServer.LOGGER.info("Using {} threads for World ticking", multiThreadWorldTickingThreads);
+    }
+}
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index 2adbd6472e78bb7f417dcae4fab90fd924486529..985f35ed57bceda10bbd3173a40da3ca81ece06a 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -6,6 +6,7 @@ import java.lang.management.ThreadInfo;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
 import org.bukkit.Bukkit;
 
 public final class WatchdogThread extends io.papermc.paper.util.TickThread // Paper - rewrite chunk system
@@ -47,14 +48,38 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
         log.log(Level.SEVERE, "Ticking entity: " + entityType + ", entity class: " + entity.getClass().getName());
         log.log(Level.SEVERE, "Entity status: removed: " + entity.isRemoved() + ", valid: " + entity.valid + ", alive: " + entity.isAlive() + ", is passenger: " + entity.isPassenger());
         log.log(Level.SEVERE, "Entity UUID: " + entityUUID);
-        log.log(Level.SEVERE, "Position: world: '" + (world == null ? "unknown world?" : world.getWorld().getName()) + "' at location (" + posX + ", " + posY + ", " + posZ + ")");
-        log.log(Level.SEVERE, "Velocity: " + (mot == null ? "unknown velocity" : mot.toString()) + " (in blocks per tick)");
+        log.log(Level.SEVERE, "Position: world: '" + (world == null ? "unknown world?" : world.getTypeKey().toString()) + "' at location (" + posX + ", " + posY + ", " + posZ + ")");        log.log(Level.SEVERE, "Velocity: " + (mot == null ? "unknown velocity" : mot.toString()) + " (in blocks per tick)");
         log.log(Level.SEVERE, "Entity AABB: " + entity.getBoundingBox());
         if (moveVec != null) {
             log.log(Level.SEVERE, "Move call information: ");
             log.log(Level.SEVERE, "Start position: (" + moveStartX + ", " + moveStartY + ", " + moveStartZ + ")");
             log.log(Level.SEVERE, "Move vector: " + moveVec.toString());
         }
+
+        if(((ServerLevel)entity.level()).currentTickingThread != null){ // Most likely actively ticking
+            log.log(Level.SEVERE, "------------------------------");
+            log.log(Level.SEVERE, "TickingThread found, dumping...");
+            log.log(Level.SEVERE, "------------------------------");
+            Thread thread = ((ServerLevel)entity.level()).currentTickingThread;
+            StackTraceElement[] elements = thread.getStackTrace();
+            log.log(Level.SEVERE, "Current Thread: " + thread.getName());
+            ThreadInfo threadInfo = ManagementFactory.getThreadMXBean().getThreadInfo(thread.getId(), Integer.MAX_VALUE);
+            log.log(Level.SEVERE, "\tPID: " + threadInfo.getThreadId()
+                    + " | Suspended: " + threadInfo.isSuspended()
+                    + " | Native: " + threadInfo.isInNative()
+                    + " | State: " + threadInfo.getThreadState());
+            if (threadInfo.getLockedMonitors().length != 0){
+                log.log(Level.SEVERE, "\tThread is waiting on monitor(s):");
+                for (MonitorInfo monitor : threadInfo.getLockedMonitors()){
+                    log.log(Level.SEVERE, "\t\tLocked on:" + monitor.getLockedStackFrame());
+                }
+            }
+            log.log(Level.SEVERE, "\tStack:");
+            for (StackTraceElement stack : io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateStacktrace(thread.getStackTrace())){
+                log.log( Level.SEVERE, "\t\t" + stack );
+            }
+        }
+        // Leaf end
     }
 
     private void dumpTickingInfo() {
@@ -204,7 +229,7 @@ public final class WatchdogThread extends io.papermc.paper.util.TickThread // Pa
                 log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Leaf!):" ); // Paper // Gale - branding changes // Leaf
                 io.papermc.paper.chunk.system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
-                WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
+               // WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
                 log.log( Level.SEVERE, "------------------------------" );
                 //
                 // Paper start - Only print full dump on long timeouts
